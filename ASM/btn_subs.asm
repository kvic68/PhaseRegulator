;---------------------------------------------------------------------------
;
; KEY_PROCESS_INTEGRATOR
; Интеграция "сырого" статуса входного канала (функция математического подавления звона и помех)
; Вызывается после опроса физической кнопки (любой реализации), и получения цифрового кода её текущего статуса: "0" или "1".
;
; ПАРАМЕТРЫ:
; 	Через status bit "T" передаётся "сырой" цифровой код текущего статуса кнопки = "0" или "1".
;	Регистровым параметром "IntegratorAddress" передаётся адрес "регистра интегратора" в памяти (ОЗУ).
;	Регистровым параметром "IntegratorLatchDepth" специфицируется "глубина защёлки" для текущего канала. 
;	(Примечание: наличие последнего параметра предполагает, что сигналы от тактовых кнопок и энкодера, например, требуют разных "глубин защёлки" - ввиду их различной динамичности и надёжности...)
;
;---------------------------------------------------------------------------
;
; ФОРМАТ РЕГИСТРА ИНТЕГРАТОРА (DInputIntegrator):
; 
; 		76543210
; 		Snnnnnnn
; 
; В целом, регистр хранит одно число (signed short int) = [-128,0,+127]
; Результат интеграции - отражается в Sign bit (он же Negative Flag "N"), означает: ="0" (кнопка отпущена) или ="1" (кнопка нажата)...
;
; Начальное состояние = 0b00000000, что означает: примерно среднее неопределённое положение защёлки, но кнопка всё же на стороне "отпущена" (что соответствует обычной ситуации: кнопки, конструктивно, "нормально разомкнутые").
; 
; Кодировка входного сигнала:
; 	СТАНДАРТ: Статус входного физического канала приходит в следующей кодировке: ="0" (кнопка отпущена) или ="1" (кнопка нажата). 
; 	(Примечание: И только так! И не перенастраивается!	Рекомендация: А если ваша реализация схемы кнопок возвращает другой, инверсный код? То просто добавьте, в ваш код, безусловную математическую XOR-инверсию, после чтения кода из Порта.)
; 	(Вопрос: А зачем так жёстко фиксировать, ведь в процедуре достаточно изменить только одну инструкцию BRTS/BRTC, чтобы кодировка входного сигнала стала инверсной? Можно было бы настраивать директивой условной компиляции...
; 	 Ответ:  Для минимизации путаницы - код конвеера обработки кнопок не модифицируется, логика неизменна! 
; 		 Напомню, что кроме Кнопок, через интеграторы обрабатываются также Энкодеры, у которых свои рекомендуемые схемы подключения и кодировки сигналов... 
; 		 Допускается, что разные группы Кнопок/Энкодеров, в системе, могут быть подключены разными схемами, и возвращать свои статусы в разных кодировках, вперемешку...
; 		 Гораздо проще и понятнее, и универсальнее: при написании кода процедуры KEY_SCAN_INPUT, добавить безусловные XOR-инверсии к некоторым определённым "физическим каналам", для приведения кодировки к единому СТАНДАРТУ!)
; Семантически - это инкрементальный двунаправленный счётчик:
; 	Если физический канал (кнопка) возвращает статус "1" ("нажата") - то на этой итерации производится декрементация (-1) регистра счётчика. 
; 	Если физический канал (кнопка) возвращает статус "0" ("отпущена") - то на этой итерации производится инкрементация (+1) регистра счётчика.
; 	Максимальное, по модулю, значение в регистре счётчика определяется константой "глубины защёлки" (LatchDepth) = [-LatchDepth, 0..+(LatchDepth-1)]. Причём, замечу, что здесь значение =0 включается в статус "кнопка отпущена"!
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

;.def	IntegratorLatchDepth	= R25	; входной параметр: "глубина защёлки" для текущего канала	(примечание: не изменяется внутри процедуры)
;.def	IntegratorAddressLow	= R26	; XL								(примечание: не изменяется внутри процедуры)
;.def	IntegratorAddressHigh	= R27	; XH								(примечание: не изменяется внутри процедуры)
; Также, параметром является status bit "T" = цифровой код текущего статуса кнопки ("0" или "1").

; Памятка: также использует/портит содержимое регистров r16, r17.

;----- Code


KEY_PROCESS_INTEGRATOR:
;		LDX DInputIntegrator
		LD	r16,	X					; Загружаем регистр Интегратора
;		MOV	r17,	IntegratorLatchDepth			; это значение мы будем менять походу - поэтому перекинем его во временный регистр, во избежание side effects...
		ldi r17,15
		BRTS	PressedDecrement__KEY_PROCESS_INTEGRATOR	; Выбираем режим модификации
	
	ReleasedIncrement__KEY_PROCESS_INTEGRATOR:
		DEC	r17						; =(LatchDepth-1)	перед сравнением, предекрементируем значение "защёлки": потому что верхняя граница счётчика должна быть <= (LatchDepth-1)
		CP	r16,	r17
		BREQ	End__KEY_PROCESS_INTEGRATOR			; r16 == (LatchDepth-1), защёлка уже на пределе - модификация запрещена...
		INC	r16						; инкрементируем счётчик интегратора
		RJMP	End__KEY_PROCESS_INTEGRATOR

	PressedDecrement__KEY_PROCESS_INTEGRATOR:
		NEG	r17						; =(-LatchDepth)	перед сравнением, переводим значение границы в дополнительный код
		CP	r16,	r17
		BREQ	End__KEY_PROCESS_INTEGRATOR			; r16 == (-LatchDepth), защёлка уже на пределе - модификация запрещена...
		DEC	r16						; декрементируем счётчик интегратора
		;RJMP	End__KEY_PROCESS_INTEGRATOR

	End__KEY_PROCESS_INTEGRATOR:
		ST	X,	r16					; Сохраняем регистр Интегратора
		RET




;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
;
; KEY_UPDATE_BUTTON_STATUS
; Фиксация статуса Кнопки (устанавливает значения в статус-регистре Кнопки),
; в зависимости от, динамически изменяющегося, [интегрированного] состояния её канала.
;
; ПАРАМЕТРЫ:
;	Регистровым параметром "IntegratorAddress" передаётся адрес "регистра интегратора" (в памяти ОЗУ), который кодирует текущее "физическое" состояние кнопки.
;	Регистровым параметром "StatusAddress" передаётся адрес "статусного регистра кнопки" (в памяти ОЗУ), который следует обновить.
;
;---------------------------------------------------------------------------
;
; ФОРМАТ СТАТУСНОГО РЕГИСТРА КНОПКИ (DButtonStatus):
; 
; 		76543210
; 		HPTnnnnn
; 
; nnnnn	= Пять битов   DButtonStatus[4:0] = счётчик количества полусекунд, в течение которых Кнопка удержива(лась/ется) "нажатой".	(фиксирует время до 16сек!)
; HPT	= В трёх битах DButtonStatus[7:5] = кодируется итоговый "статус-код кнопки" (см. макроопределения констант).
; T	= Флаг "времени удержания" кнопки: 0-короткое или 1-длинное.
; P	= Флаг "зафиксировано полноценное нажатие кнопки": "0" - кнопка не нажималась, "1" - было нажатие.
; H	= Флаг "кнопка удерживается в нажатом состоянии": "0" - сейчас кнопка "отпущена", "1" - сейчас кнопка "нажата и удерживается".
; 
; Начальное состояние = 0b00000000 означает: кнопка "не нажата и не нажималась", исходное положение для всех кнопок - бывает только после "сброса"...	(статус-код кнопки = "не нажата"; счётчик времени предыдущего нажатия = обнулён)
; Начальное состояние = 0b11111111 означает: кнопка "удерживается и отпущена одновременно" - это служебное, исключительное состояние: "фиксация, до ожидания следующего отпускания" кнопки - ОТЛОЖЕННЫЙ СБРОС...	(запрещённый статус-код кнопки = запрещает прикладному коду реакцию на эту кнопку)	(примечание: а при следующем отпускании физической кнопки, статус-регистр будет АВТОМАТИЧЕСКИ "сброшен в ноль", в исходное положение!)
; (Примечание: также, после обработки статуса кнопки прикладным кодом, статусный регистр РЕКОМЕНДУЕТСЯ просто сбрасываеть "в ноль" или "в единицы" - это простой способ сообщить остальному прикладному коду, что данное событие уже обработано и не требует дальнейшего участия...)
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

;.def	IntegratorAddressLow	= R26	; XL	(примечание: не изменяется внутри процедуры)
;.def	IntegratorAddressHigh	= R27	; XH	(примечание: не изменяется внутри процедуры)
;.def	StatusAddressLow	= R28	; YL	(примечание: не изменяется внутри процедуры)
;.def	StatusAddressHigh	= R29	; YH	(примечание: не изменяется внутри процедуры)

; Памятка: также использует/портит содержимое регистров r16, r17.

;----- Code


KEY_UPDATE_BUTTON_STATUS:
;LDX DInputIntegrator
;LDY	DButtonStatus
		LD	r17,	Y					; Загружаем статус-регистр Кнопки
		BST	r17,	BUTTON_IS_HOLDDOWN			; Флаг "кнопка удерживается в нажатом состоянии" -> T
		LD	r16,	X					; Загружаем регистр Интегратора
		TST	r16						; Текущее состояние канала кнопки -> N
		BRMI	ButtonHold__KEY_UPDATE_BUTTON_STATUS	
	
	ButtonReleased__KEY_UPDATE_BUTTON_STATUS:			
		; (состояние: сейчас кнопка "отпущена")
		BRTC	Exit__KEY_UPDATE_BUTTON_STATUS			; Кнопка УЖЕ считалась "отпущенной" - поэтому ничего сейчас делать не нужно...
		; (состояние: но в статус-регистре ещё хранится старый статус "удерживается")
		SBRC	r17,	BUTTON_IS_PRESSED			; состояние: кнопка "удерживается и отпущена одновременно"?
		RJMP	ResetStatus__KEY_UPDATE_BUTTON_STATUS

		ANDI	r17,	~(1<<BUTTON_IS_HOLDDOWN)		; установить статус = кнопка "отпущена",
		ORI	r17,	(1<<BUTTON_IS_PRESSED)			; ... но фиксируем, что "было нажатие".
									; при этом, флаг "времени удержания" (короткое или длинное) уже правильно установлен в регистре - мы его не трогаем.
		RJMP	Save__KEY_UPDATE_BUTTON_STATUS

	ResetStatus__KEY_UPDATE_BUTTON_STATUS:
		; (установлено служебное и исключительное состояние: "фиксация, до ожидания следующего отпускания" кнопки - ОТЛОЖЕННЫЙ СБРОС...)
		; (и при этом, физическую кнопку только что отпустили!)
		CLR	r17						; статус-регистр "сбросить в ноль", в исходное положение.
		RJMP	Save__KEY_UPDATE_BUTTON_STATUS
	
	ButtonHold__KEY_UPDATE_BUTTON_STATUS:			
		; (состояние: сейчас кнопка "удерживается")
		BRTS	Exit__KEY_UPDATE_BUTTON_STATUS			; Кнопка УЖЕ считалась "удерживаемой" - поэтому ничего сейчас делать не нужно...
		; (состояние: но в статус-регистре ещё хранится старый статус "отпущена")
		LDI	r17,	(1<<BUTTON_IS_HOLDDOWN)			; установить статус = "кнопка удерживается в нажатом состоянии"; 
									; при этом, счётчик "времени предыдущего удержания" принудительно обнуляется; 
									; и т.к. кнопку только-только нажали, то также сбрасывается её "статус-код" (до прояснения ситуации)...
		;RJMP	Save__KEY_UPDATE_BUTTON_STATUS
	
	Save__KEY_UPDATE_BUTTON_STATUS:
		ST	Y,	r17					; Сохраняем статус-регистр Кнопки
	Exit__KEY_UPDATE_BUTTON_STATUS:
		RET

;---------------------------------------------------------------------------
; (Головная процедура конвеера обработки кнопок)
;
; KEY_ENHANCE_TIME_FOR_ALL_BUTTONS
; Наращивает таймеры для удерживаемых кнопок (должна запускаться по событию таймера, точно раз в 0.5 сек)
; 	Для Энкодеров не используется - предназначена только для обработки Кнопок!
; 	С физическими кнопками также не работает, а только перебирает/обрабатывает их Статусные регистры!
;
; АЛГОРИТМ:
; 	для кнопок удерживаемых в нажатом состоянии, 
;	наращивает "счётчик времени удержания" (если он ещё меньше своего максимума < 0b11111),
; 	и также, обновляет значение Флага "времени удержания" кнопки = 0-короткое или 1-длинное.
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Без параметров.

; Памятка: также использует/портит содержимое регистров r16, r17, r18,
;	Y(R29:R28).

;----- Code


KEY_ENHANCE_TIME_FOR_ALL_BUTTONS:

;		LDI	StatusAddressLow,	Low(DButtonStatus)	; (примечание: здесь загружаем в регистр адрес, а не значение)
;		LDI	StatusAddressHigh,	High(DButtonStatus)	; где регистр StatusAddress = Y(R29:R28)
		LDY DButtonStatus
		LDI	r18,	CButtonInputChannelCount		; r18 = счётчик цикла
		
	Loop__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS:
		LD	r17,	Y+					; r17 = Загружаем текущий статус-регистр Кнопки
		
		BST	r17,	BUTTON_IS_HOLDDOWN			; Флаг "кнопка удерживается в нажатом состоянии" -> T
		BRTC	Skip__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS		; ещё "не нажатые" кнопки пропускаем...
		BST	r17,	BUTTON_IS_PRESSED			; Флаг "зафиксировано полноценное нажатие кнопки" -> T
		BRTS	Skip__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS		; уже "отпущенные" кнопки пропускаем...
		
		; (состояние: текущая кнопка нажата и удерживается)
		MOV	r16,	r17
		ANDI	r16,	(0b11111<<BUTTON_HOLDING_TIME)		; r16 = выделить значение "счётчика времени удержания" кнопки
		
		CPI	r16,	0b11111					; сравнить значение "счётчика времени удержания" с его максимумом
		BREQ	Skip__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS		; если значение счётчика уже на максимуме - то статус этой кнопки больше не меняется...
		
		; (состояние: требуется увеличить значение "счётчика времени удержания")
		INC	r16
		ANDI	r17,	~(0b11111<<BUTTON_HOLDING_TIME)		; обнулить биты счётчика в статус-регистре
		OR	r17,	r16					; побитово скопировать в статус-регистр новое значение счётчика
		
		; (состояние: требуется обновить статус-код)
		CPI	r16,	CShortButtonTouchDuration		; сравнить значение "счётчика времени удержания" с эталонным граничным значением, различающим статусы "Short/Long"
									; если r16< CShortButtonTouchDuration ("Short" time), то C = 1	-> Флаг "времени удержания" кнопки: BUTTON_HOLDEN_LONG = 0-короткое
									; если r16>=CShortButtonTouchDuration ("Long" time),  то C = 0	-> Флаг "времени удержания" кнопки: BUTTON_HOLDEN_LONG = 1-длинное
		; Реализация 1: (универсальная и избыточная)
		;STOREB	SREG,	SREG_C					; C (Carry Flag) -> T (Transfer bit, Bit Copy Storage)
		;BLD	r17,	BUTTON_HOLDEN_LONG			; T -> копируем в статус-регистр кнопки, в бит Флага "времени удержания"
		;LDI	r16,	1<<BUTTON_HOLDEN_LONG
		;EOR	r17,	r16					; инвертируем бит Флага "времени удержания" = теперь он равен требуемому значению
		; Реализация 2: (упрощённая и оптимальная: т.к. у нас счётчик растёт только вверх, а изначально он всегда обнулён, следовательно, здесь бит BUTTON_HOLDEN_LONG может только установиться из 0 в 1)
		BRLO	Save__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS		; если r16< CShortButtonTouchDuration ("Short" time), то пропускаем установку Флага "времени удержания"...
		ORI	r17,	(1<<BUTTON_HOLDEN_LONG)			; Флаг "времени удержания" = 1

	Save__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS:
		ST	-Y,	r17					; Сохраняем текущий статус-регистр Кнопки
		LD	r17,	Y+					; (коррекция: адрес в регистре Y++)
	Skip__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS:
		DEC	r18						; счётчик цикла--
		BRNE	Loop__KEY_ENHANCE_TIME_FOR_ALL_BUTTONS

		RET



;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
; (Головная процедура конвеера обработки кнопок)
;
; KEY_RESET_STATUS_FOR_ALL_BUTTONS
; Обнулить все зарегистрированные события от Кнопок и Энкодеров (вызывается при переходе интерфейса в другую Подсистему, в которой задействованы другие группы кнопок).
; Использование данной процедуры подавляет "эффекты" от лишних нажатий кнопок, зарегистрированных но не обработанных, в предыдущем режиме интерфейса - чтобы они, внезапно, не были обнаружены и обработаны в новом режиме интерфейса (когда уже не актуальны).
;
;
; Инструкция к применению: 
; 	Обычно, при обработке кнопочных событий, если распознаётся нажатие управляющей кнопки, одной или группы (IF_BUTTON_HAVE_STATUS/OR_BUTTON_HAVE_STATUS) - то реализуется соответствующая прикладная реакция, а статус обработанных кнопок - сбрасывается (но только статус обработанных кнопок!).
; 	Если, в некотором режиме интерфейса, часть кнопок не задействована - то они не опрашиваются, не срабатывают, их статус не обнуляется, а запоминается и хранится (такая кнопка становится "миной отложенного действия").
; 	Следует также учитывать "защиту от дурака": пользователь будет нажимать на всё подряд!
; 	При реализации прикладной логики вашего Устройства: Вызывайте данную процедуру единожды, всякий раз, когда переключаете интерфейс в другую Подсистему - это "разминирует все заложенные ловушки".
;
; Принцип действия:
; 	Статус-регистры всех Кнопок "СБРАСЫВАЮТСЯ В ЕДИНИЦЫ (SER)" - так установится статус "ОТЛОЖЕННЫЙ СБРОС".	(Напомню: Далее, для тех кнопок которые отпущены, или как только они будут отпущены, статус-регистры автоматически установятся в исходное, нулевое состояние.)
; 	Счётные-регистры всех Энкодеров обнуляются ("счётчик тиков"=0).
;
;---------------------------------------------------------------------------

;----- Subroutine Register Variables

; Без параметров.

; Памятка: также использует/портит содержимое регистров r16, r17.
; Примечание: а вот индексные регистры Y(R29:R28), хоть и используются в процедуре, но они экранируются через Стек - не изменяются.	(Это необходимость, для исключения побочных эффектов: поскольку Y(R29:R28) - не являются традиционными "временными переменными", поэтому их очень легко забыть... А данная процедура вызывается из очень многих сложных мест прикладного кода - невозможно просчитать!)

;----- Code


KEY_RESET_STATUS_FOR_ALL_BUTTONS:
		push r16
		push r17
		PUSH	YL						; запомнить значения
		PUSH	YH

		; Счётные-регистры всех Энкодеров обнуляются:
;		LDI	YL,	Low(DEncoderStatus)			; (примечание: здесь загружаем в регистр адрес, а не значение)
;		LDI	YH,	High(DEncoderStatus)
;		LDI	r17,	(CEncoderInputChannelCount/2)		; количество Энкодеров в системе	(Примечание: Количество входных каналов энкодеров CEncoderInputChannelCount - это всегда чётное число: поскольку у Энкодеров по два входных канала, а также, по два регистра, которые мы и перебираем!)
;	EncoderLoop__KEY_RESET_STATUS_FOR_ALL_BUTTONS:
;		LD	r16,	Y+					; адрес в регистре Y++ (минуем: статус-регистр)
;		CLR	r16						; сохраним ноль в следующий регистр (обнулим)
;		ST	Y+,	r16					; адрес в регистре Y++ (минуем: счётчик тиков)
;		DEC	r17						; счётчик цикла--
;		BRNE	EncoderLoop__KEY_RESET_STATUS_FOR_ALL_BUTTONS


		; Статус-регистры всех Кнопок СБРАСЫВАЮТСЯ В "ОТЛОЖЕННЫЙ СБРОС":
		LDI	YL,	Low(DButtonStatus)			; (примечание: здесь загружаем в регистр адрес, а не значение)
		LDI	YH,	High(DButtonStatus)
		LDI	r17,	CButtonInputChannelCount		; количество Кнопок в системе
		LDI	r16,	0b11111111				; в статус-регистры загрузить код = "ОТЛОЖЕННЫЙ СБРОС"
	ButtonLoop__KEY_RESET_STATUS_FOR_ALL_BUTTONS:
		ST	Y+,	r16					; адрес в регистре Y++ (минуем: статус-регистр)
		DEC	r17						; счётчик цикла--
		BRNE	ButtonLoop__KEY_RESET_STATUS_FOR_ALL_BUTTONS
		

		POP	YH						; восстановить значения
		POP	YL
		pop r17
		pop r16
		RET

//--------------------------------------------------------------------------------------
longKeyHold:	PUSHF
				push r16
				lds r16,(MODE)
lkh0:			cpi r16,0
				brne lkh1
					ldi r16,1		; длинное нажатие в рабочем режиме включаем режим разгона
					sts (MODE),r16
					ldi r16,$FF
					sts (FL_NEW_U),r16
					sts (FL_NEW_M),r16
				rjmp lkhEx

lkh1:			cpi r16,1
				brne lkh2
					ldi r16,2		; длинное нажатие в режиме разгона включаем стоп
					sts (MODE),r16
					ldi r16,$FF
					sts (FL_NEW_U),r16
					sts (FL_NEW_M),r16
				rjmp lkhEx

lkh2:			cpi r16,2
				brne lkh3
					ldi r16,1		; длинное нажатие в режиме стоп включаем режим разгона
					sts (MODE),r16
					ldi r16,$FF
					sts (FL_NEW_U),r16
					sts (FL_NEW_M),r16
				rjmp lkhEx

lkh3:			cpi r16,3
				brne lkhEx
					ldi r16,0		; длинное нажатие в режиме "внешний стоп" включаем основной режим стабилизации
					sts (MODE),r16
					ldi r16,$FF
					sts (FL_NEW_U),r16
					sts (FL_NEW_M),r16
						ldi r16,0
						sts (SOUNDNUMBER),r16
				rjmp lkhEx
lkhEx:			pop r16
				POPF	
				ret
//--------------------------------------------------------------------------------------
shortKeyPress:	PUSHF
				push r16	
				lds r16,(MODE)
skp0:			cpi r16,0
				brne skp1
					ldi r16,2		; короткое нажатие в рабочем режиме включаем режим "стоп" на выходе 0
					sts (MODE),r16
					ldi r16,$FF
					sts (FL_NEW_U),r16
					sts (FL_NEW_M),r16
					rjmp skpEx
skp1:			cpi r16,1
				brne skp2
					ldi r16,0		; короткое нажатие в режиме "стоп" включаем основной режим стабилизации, выключаем разгон
					sts (MODE),r16
					clr r16
					sts (FL_MAX_U),r16
					dec r16
					sts (FL_NEW_U),r16
					sts (FL_NEW_M),r16
					rjmp skpEx
skp2:			cpi r16,2
				brne skp3
					ldi r16,0		; короткое нажатие в режиме "разгон" включаем основной режим стабилизации
					sts (MODE),r16
					clr r16
					sts (FL_MAX_U),r16
					dec r16
					sts (FL_NEW_U),r16
					sts (FL_NEW_M),r16
					rjmp skpEx
skp3:			cpi r16,3
				brne skp4
					//				; короткое нажатие в режиме "внешний стоп"
						ldi r16,0
						sts (SOUNDNUMBER),r16
					rjmp skpEx
skp4:			//
skpEx:			pop r16
				POPF
				ret
//--------------------------------------------------------------------------------------
encoder:		in		r16,PinD							;загружаем значение порта D в регистр 
				andi r16,(1<<encPhaseA)|(1<<encPhaseB)		;выделить два бита R16

				lds	r17,(REG_AB)			
				cpi		r17,0								;регистр RegAB равен 0?
				brne	encoderScan							;если нет , уходим на метку ScanEncoder
				cpi		r16,0								;на обоих портах 0?
				brne	encoderExit								;если нет , выходим нах
				ldi		r17,128								;иначе "взводим" наш алгоритм на подсчет импульсов
				rjmp	encoderExit								;т.е. в следующий раз пойдем по другой ветви алгоритма
encoderScan:	cpi 	r16,(1<<encPhaseA)|(1<<encPhaseB)	;на обоих линиях высокий уровень ?
				breq	encoderGoWork						;если да , то пошли их сравнивать
				cpi		r16,(1<<encPhaseA)					;нет? тогда может на первой линии лог.единица
				brne	encoderM1							;если нет то пошли проверять вторую линию
				inc		r17									;иначе увеличиваем значение RegA на единицу
				cpi		r17,250								;подстраховываемся от переполнения и если досчитали
				brsh	encoderWorkA						;до 250,значит полюбому было вращение в сторону А
				rjmp	encoderExit							;и выходим
encoderM1:		cpi		r16,(1<<encPhaseB)					;может на второй линии лог. единица?
				brne	encoderM2							;если опять нет,выходим нах
				dec		r17									;иначе увеличиваем значение RegB на единицу
				cpi		r17,5								;подстраховываемся от переполнения и если досчитали
				brlo	encoderWorkB						;до 5,значит полюбому было вращение в сторону В
encoderM2:		rjmp	encoderExit							;выходим
encoderGoWork:	cpi		r17,128								;сравниваем, что у нас там накопилось в регистре
				breq	encoderExit							;если ничего не изменилось - выходим (хотя такого мне кажется не должно случиться)
				brlo	encoderWorkA						;если RegAB меньше 128 - делаем действие А
encoderWorkB:												;иначе делаем действие В
				;ДЕЙСТВИЕ В increase
				lds r16,(ACTIONS_FLAGS)
				SETB r16,6
				CLRB r16,5
				sts (ACTIONS_FLAGS),r16
				clr		r17									;после выполнения действия ОБЯЗАТЕЛЬНО очищаем RegAB
				rjmp	encoderExit							;выходим
encoderWorkA:
				;ДЕЙСТВИЕ А decrease
				lds r16,(ACTIONS_FLAGS)
				CLRB r16,6
				SETB r16,5
				sts (ACTIONS_FLAGS),r16
				clr		r17									;после выполнения действия ОБЯЗАТЕЛЬНО очищаем RegAB
encoderExit:	sts (REG_AB),r17							;выходим
				ret
//--------------------------------------------------------------------------------------
pressButton:	in r16,btnPin
				andi r16,(1<<btnPinNo)
				ldi r17,$FF
				eor r16,r17
				bst r16,btnPinNo

				LDX DInputIntegrator
				LDY	DButtonStatus

				call KEY_PROCESS_INTEGRATOR
				call KEY_UPDATE_BUTTON_STATUS	
			
				lds r17,(ACTIONS_FLAGS)
				lds r16,(DButtonStatus)
				andi r16,0b11100000
				cpi r16,(BSC_LongHold<<BUTTON_STATUS_CODE)
				brne chkShortPress
				SETB r17,4
				rjmp pressButtonEnd
chkShortPress:	cpi r16,(BSC_ShortPress<<BUTTON_STATUS_CODE)
				brne pressButtonEnd
				SETB r17,3
pressButtonEnd:	sts (ACTIONS_FLAGS),r17
				ret
//--------------------------------------------------------------------------------------
